---
title: "assessing stability of noise models"
output:
  html_document:
    toc: true
    toc_depth: 3
    number_sections: true

---


# intro

Analysis to help guide use of noise models in pattern analysis.

Questions this analysis might help inform:

a. Is noise structure stable across runs within a task? across tasks?
   - For a given run (or task), can noise estimates from different runs (or tasks) be used to normalize patterns?
      - Does filtering higher-motion frames boost stability?
   - Are there 'bad' tasks or glms whose noise models should be scrutinized further?
b. What aspects of noise structure are stable across runs/tasks?
   - diagonal (variance), offidagonal (covariance)? --- Should residual timeseries variance be used to downweight individual vertices?
   - magnitude (scale), direction (pattern)? --- should covariance matrices be converted into correlation matrices?
c. What is the impact on cross-task stability of concatenating timeseries across runs versus estimating runwise then aggregating over runs?
   - how should noise models be estimated?

Stability statistics:

* stability can be assessed in mean (location), variance (scale/magnitude), angle (pattern 'shape')
* cor: linear correlation, sensitive to pattern shape
* cossim: cosine similarity, sensitive to pattern shape and location
* rmse: root mean squared error (a distance measure), sensitive to shape, location, and scale


```{r setup, include = FALSE}

source(here::here("code", "_packages.R"))
source(here("code", "read-behav.R"))
source(here("code", "_vars.R"))
source(here("code", "_atlases.R"))
source(here("code", "_settings.R"))
source(here("code", "_funs.R"))
library(mikeutils)

do.network <- TRUE
do.calcstabil <- FALSE

glminfo <- data.frame(
  task = c("Axcpt", "Cuedts", "Stern", "Stroop"),
  name.glm = c(
    "baseline_aggressive1_EVENTS_censored_shifted"
  ),
  stringsAsFactors = FALSE
)
glminfo <- as.data.table(glminfo)


if (do.network) {
  rois <- unique(get.network(parcellation$key))
} else {
  rois <- parcellation$key
}

fdmasks <- seq(0.3, 0.9, 0.2)

taskruns <- sort(combo_paste(tasks, c("run1", "run2")))

## functions ----

pdist2 <- function(A,B) {
    an = apply(A, 1, function(rvec) crossprod(rvec,rvec))
    bn = apply(B, 1, function(rvec) crossprod(rvec,rvec))
    m = nrow(A)
    n = nrow(B)
    tmp = matrix(rep(an, n), nrow=m) 
    tmp = tmp +  matrix(rep(bn, m), nrow=m, byrow=TRUE)
    tmp - 2 * tcrossprod(A,B)
}


cosinesim_m <- function(M) {
   S <- diag(1 / apply(M, 2, function(x) sqrt(sum(x^2))))
   MS <- tcrossprod(M, S)
   crossprod(MS)
}


crossrun_stats <- function(x) {
   
   W1 <- x[, , 1]
   W2 <- x[, , 2]
   
   lt <- lower.tri(W1)
   w1 <- W1[lt]
   w2 <- W2[lt]
   
   r <- cor(w1, w2)
   s <- cosinesim(w1, w2)
   e <- sqrt(mean((w1 - w2)^2))
   
   data.frame(r, s, e)
   
}


get_lt <- function(m, vert_names, vert_names_keep) {
   
   dimnames(m) <- list(row = vert_names, col = vert_names, run = c("run1", "run2"))
   
   m <- m[vert_names_keep, vert_names_keep, ]
   
   m1 <- m[, , 1]
   m2 <- m[, , 2]
   
   m1 <- m1[lower.tri(m1)]
   m2 <- m2[lower.tri(m2)]
   
   cbind(m1, m2)

}

get_diag <- function(m, vert_names, vert_names_keep) {
   
   dimnames(m) <- list(row = vert_names, col = vert_names, run = c("run1", "run2"))
   
   m <- m[vert_names_keep, vert_names_keep, ]
   
   m1 <- m[, , 1]
   m2 <- m[, , 2]
   
   m1 <- diag(m1)
   m2 <- diag(m2)
   
   cbind(m1, m2)

}


```



```{r}


if (do.calcstabil) {
  
  source(here("code", "noise", "est_noise_model_stabil_concat.R"))
  source(here("code", "noise", "est_noise_model_stabil_runwise.R"))
  
} else {

	R <- readRDS(here("out", "invcov", "invcov-stability_est-runwise.RDS"))
	R_c <- readRDS(here("out", "invcov", "invcov-stability_est-concat.RDS"))

}


```

subjs with complete data:

```{r}

## wrangle ----

## array -> data.frame

R_offd <- apply(
	R, c("subj", "roi", "fdmask", "component", "measure"),
	function(x) x[lower.tri(x)]
)

r_offd <- reshape2::melt(R_offd)

r_offd <- r_offd %>% filter(!is.na(value))  ## get rid of bad subjs


unique(r_offd$subj)  ## subjs with complete data

## bind row/col names:

inds_lt <- matrix(1:length(taskruns)^2, nrow = length(taskruns))
inds_lt <- inds_lt[lower.tri(inds_lt)]
labs_lt <- 
  reshape2::melt(R[, , 1, 1, 1, 1, 1])[inds_lt, c(".row", ".col")] %>%
  separate(.row, into = c("row_task", "row_run")) %>%
  separate(.col, into = c("col_task", "col_run"))

labs_lt <- cbind(Var1 = 1:nrow(labs_lt), labs_lt)

r_offd <- full_join(r_offd, labs_lt, by = "Var1")

r_offd %<>% mutate(fdmask = as.factor(gsub("mask", "", fdmask)))

```



# cross-run stability

Within-task comparisons.

## mean across tasks

```{r, fig.width = 9, fig.height = 5}


r_offd <- r_offd %>% mutate(is_within_task = row_task == col_task)

sum_task <- bind_rows(
    
    r_offd %>%
    
      filter(measure %in% c("cor", "cossim")) %>%
    	group_by(subj, roi, fdmask, component, measure) %>%	
      mutate(value = atanh(value)) %>%
    	summarize(
    		wthntsk = tanh(mean(value[is_within_task])),
    		btwntsk = tanh(mean(value[!is_within_task]))
    	),
    
    r_offd %>%
      
    	filter(measure == "rmse") %>%
    	group_by(subj, roi, fdmask, component, measure) %>%	
    	summarize(
    		wthntsk = mean(value[is_within_task]),
    		btwntsk = mean(value[!is_within_task])
    	)

  )


sum_task %>%
   
   filter(component == "cov") %>%
   
   ggplot(aes(fdmask, wthntsk)) +
   stat_summary(fun.data = "mean_cl_boot") +
   facet_grid(vars(measure), vars(roi), scales = "free_y") +
   labs(
	   x = "fdmask threshold",
	   y = "estimate", 
	   title = "stability of noise covariance across runs (within-task)"
   )


sum_task %>%
   
   filter(component == "var") %>%
   
   ggplot(aes(fdmask, wthntsk)) +
   stat_summary(fun.data = "mean_cl_boot") +
   facet_grid(vars(measure), vars(roi), scales = "free_y") +
   labs(
	   x = "fdmask threshold", 
	   y = "estimate", 
	   title = "stability of noise variance across runs (within-task)"
   )


```

Stability of covariance strongly depends on amount of data (number of frames), above and beyond amount of motion in frames.
Similar story told with variances, but much less strongly.

## per task


```{r, fig.width = 11, fig.height = 6}

r_offd <- r_offd %>% 
  mutate(
    is_within_Axcpt = row_task == col_task & row_task == "Axcpt",
    is_within_Cuedts = row_task == col_task & row_task == "Cuedts",
    is_within_Stern = row_task == col_task & row_task == "Stern",
    is_within_Stroop = row_task == col_task & row_task == "Stroop"
    )


r_offd$task <- apply(
  r_offd[, c("is_within_Axcpt", "is_within_Cuedts", "is_within_Stern", "is_within_Stroop")],
  1, 
  function(x) {
    ind <- which(x)
    if (length(ind) == 0) ind <- 0
    switch(ind + 1, "btwn_task", "Axcpt", "Cuedts", "Stern", "Stroop")
  }
)


sum_task_each <- bind_rows(
    
   r_offd %>%
    
      filter(measure %in% c("cor", "cossim")) %>%
    	group_by(subj, roi, fdmask, component, measure, task) %>%
      mutate(value = atanh(value)) %>%
    	summarize(value = tanh(mean(value))),
    
    r_offd %>%
      
    	filter(measure == "rmse") %>%
    	group_by(subj, roi, fdmask, component, measure, task) %>%	
    	summarize(value = mean(value))

  )


sum_task_each %>%
   
   filter(component == "cov", !task %in% "btwn_task") %>%
   
   ggplot(aes(fdmask, value, color = task)) +
   stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width = 0.5)) +
   facet_grid(vars(measure), vars(roi), scales = "free_y") +
   labs(
	   x = "fdmask threshold",
	   y = "estimate", 
	   title = "Stability of noise covariance across runs"
   ) +
  
  scale_color_viridis_d() +
  theme(legend.position = "top")


sum_task_each %>%
   
   filter(component == "var", !task %in% "btwn_task") %>%
   
   ggplot(aes(fdmask, value, color = task)) +
   stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width = 0.5)) +
   facet_grid(vars(measure), vars(roi), scales = "free_y") +
   labs(
	   x = "fdmask threshold",
	   y = "estimate", 
	   title = "Stability of noise variance across runs"
   ) +
  
  scale_color_viridis_d() +
  theme(legend.position = "top")


```

Large differences in stability of covariance across tasks.
Cuedts > Axcpt > Stern > Stroop.
This also matches the rank order of the number of TRs per task (in alphabetical order): `r n.trs`



# cross-task stability


## mean across tasks

```{r, fig.width = 9, fig.height = 5}


sum_task_each %>%

  filter(component == "cov", task == "btwn_task") %>%
  
  ggplot(aes(fdmask, value)) +
  stat_summary(fun.data = "mean_cl_boot") +
  facet_grid(vars(measure), vars(roi), scales = "free_y") +
  labs(
    x = "fdmask threshold",
    y = "estimate",
    title = "stability of noise covariance across tasks"
  )


sum_task_each %>%

   filter(component == "var", task == "btwn_task") %>%

   ggplot(aes(fdmask, value)) +
   stat_summary(fun.data = "mean_cl_boot") +
   facet_grid(vars(measure), vars(roi), scales = "free_y") +
   labs(
	x = "fdmask threshold",
	y = "estimate",
	title = "stability of noise variance across tasks"
	)


```

Similar story as cross-run within-task.
More frames improves cross-task stability of noise covariance, above and beyond amount of motion.
Less so with variances (variances already relatively stable).


## per run

Within run 1 (run1~run1), within run 2 (run2~run2), between run (run1~run2).
All comparisons between task.


```{r, fig.width = 10, fig.height = 6}



r_offd <- r_offd %>% 
  mutate(
    is_within_run1 = row_run == col_run & row_run == "run1",
    is_within_run2 = row_run == col_run & row_run == "run2"
    )


r_offd$run <- apply(
  r_offd[, c("is_within_run1", "is_within_run2")],
  1, 
  function(x) {
    ind <- which(x)
    if (length(ind) == 0) ind <- 0
    switch(ind + 1, "btwn_run", "run1", "run2")
  }
)




sum_run <- bind_rows(
    
   r_offd %>%
    
      filter(measure %in% c("cor", "cossim"), task == "btwn_task") %>%
    	group_by(subj, roi, fdmask, component, measure, run) %>%
      mutate(value = atanh(value)) %>%
    	summarize(value = tanh(mean(value))),
    
    r_offd %>%
      
    	filter(measure == "rmse", task == "btwn_task") %>%
    	group_by(subj, roi, fdmask, component, measure, run) %>%	
    	summarize(value = mean(value))

  )




sum_run %>%
   
   filter(component == "cov") %>%
   
   ggplot(aes(fdmask, value, color = run)) +
   stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width = 0.5)) +
   facet_grid(vars(measure), vars(roi), scales = "free_y") +
   labs(
	   x = "fdmask threshold",
	   y = "estimate", 
	   title = "Stability of noise covariance across runs"
   ) +
  
  scale_color_brewer(type = 'qual', palette = 2) +
  theme(legend.position = "top")



sum_run %>%
   
   filter(component == "var") %>%
   
   ggplot(aes(fdmask, value, color = run)) +
   stat_summary(fun.data = "mean_cl_boot", position = position_dodge(width = 0.5)) +
   facet_grid(vars(measure), vars(roi), scales = "free_y") +
   labs(
	   x = "fdmask threshold",
	   y = "estimate", 
	   title = "Stability of noise variance across runs"
   ) +
  
  scale_color_brewer(type = 'qual', palette = 2) +
  theme(legend.position = "top")


```

Run (1_AP, 2_PA) has weak impact on covariances (between run less stable), but strong impact on variances.



## concatenated

With noise models from runs concatenated (along the time-dimension) prior to estimation.

```{r}


## ----

R_c_offd <- apply(
	R_c, c("subj", "roi", "component", "measure"),
	function(x) x[lower.tri(x)]
)

r_c_offd <- reshape2::melt(R_c_offd)

r_c_offd <- r_c_offd %>% filter(!is.na(value))  ## get rid of bad subjs


unique(r_c_offd$subj)  ## subjs with complete data

## bind row/col names:

inds_lt <- matrix(1:length(tasks)^2, nrow = length(tasks))
inds_lt <- inds_lt[lower.tri(inds_lt)]
labs_lt <- reshape2::melt(R_c[, , 1, 1, 1, 1])[inds_lt, c(".row", ".col")]
labs_lt <- cbind(Var1 = 1:nrow(labs_lt), labs_lt)

r_c_offd <- full_join(r_c_offd, labs_lt, by = "Var1")




## ----



sum_task_c <- bind_rows(
    
    r_c_offd %>%
    
      filter(measure %in% c("cor", "cossim")) %>%
    	group_by(subj, roi, component, measure) %>%	
      mutate(value = atanh(value)) %>%
    	summarize(value = tanh(mean(value))),
    
    r_c_offd %>%
      
    	filter(measure == "rmse") %>%
    	group_by(subj, roi, component, measure) %>%	
    	summarize(value = mean(value))

  )




sum_task_c %>%
  
  filter(component == "cov") %>%
  
  ggplot(aes(roi, value)) +
  stat_summary(fun.data = "mean_cl_boot") +
  facet_grid(vars(measure), scales = "free_y") +
  labs(
    x = "ROI",
    y = "estimate",
    title = "stability of noise covariance across tasks"
  )



sum_task_c %>%
  
  filter(component == "var") %>%

  ggplot(aes(roi, value)) +
  stat_summary(fun.data = "mean_cl_boot") +
  facet_grid(vars(measure), scales = "free_y") +
  labs(
    x = "ROI",
    y = "estimate",
    title = "stability of noise variance across tasks"
  )




```


```{r fig.width = 10, fig.height = 3}

## matrices ----

R_bar_cor <- 
  apply(
    atanh(R_c[, , , , , c("cor", "cossim")]),
    c(".row", ".col", "roi", "component", "measure"), 
    mean, na.rm = TRUE
    ) %>% tanh

R_bar_rmse <- 
  apply(
    R_c[, , , , , c("rmse"), drop = FALSE],
    c(".row", ".col", "roi", "component", "measure"), 
    mean, na.rm = TRUE
    )

R_bar <- abind(R_bar_cor, R_bar_rmse, along = length(dim(R_bar_cor)))
dimnames(R_bar) <- dimnames(R_c)[-3]
r_bar <- reshape2::melt(R_bar)


## plot ----


r_bar$value[is_equal(r_bar$value, 0)] <- NA
r_bar$value[is_equal(r_bar$value, 1)] <- NA

for (component.i in c("cov", "var")) {
  
  for (stat.i in c("cor", "cossim", "rmse")) {

    p_bar <- r_bar %>%
    	
    	filter(component == component.i, measure == stat.i) %>%
      
      mutate(.col = factor(.col, levels = rev(unique(.col)))) %>%
      
    	ggplot(aes(.row, .col, fill = value)) +
    	
    	geom_raster() +
    	facet_grid(cols = vars(roi)) +
    	scale_fill_viridis_c(option = "magma") +
    	theme(
    	  axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), 
    	  legend.position = "top",
    	  axis.title = element_blank(),
    	  legend.text = element_text(size = 8)
    	  ) +
    	
      labs(
        title = paste0("fdmask 0.9, component: ", component.i, ", measure: ", stat.i)
      )
    
    print(p_bar)
    
    
  }
  
}

```
















# matrices



```{r fig.width = 12, fig.height = 4}

## aggregate ----

R_bar_cor <- 
  apply(
    atanh(R[, , , , , , c("cor", "cossim")]),
    c(".row", ".col", "roi", "fdmask", "component", "measure"), 
    mean, na.rm = TRUE
    ) %>% tanh

R_bar_rmse <- 
  apply(
    R[, , , , , , c("rmse"), drop = FALSE],
    c(".row", ".col", "roi", "fdmask", "component", "measure"), 
    mean, na.rm = TRUE
    )

R_bar <- abind(R_bar_cor, R_bar_rmse, along = length(dim(R_bar_cor)))
dimnames(R_bar) <- dimnames(R)[-3]
r_bar <- reshape2::melt(R_bar)


## plot ----


r_bar$value[is_equal(r_bar$value, 0)] <- NA
r_bar$value[is_equal(r_bar$value, 1)] <- NA

for (component.i in c("cov", "var")) {
  
  for (stat.i in c("cor", "cossim", "rmse")) {
    
    
    p_bar <- r_bar %>%
    	
    	filter(fdmask == "mask0.9", component == component.i, measure == stat.i) %>%
      
      mutate(.col = factor(.col, levels = rev(unique(.col)))) %>%
      
    	ggplot(aes(.row, .col, fill = value)) +
    	
    	geom_raster() +
    	facet_grid(cols = vars(roi)) +
    	scale_fill_viridis_c(option = "magma") +
    	theme(
    	  axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), 
    	  legend.position = "top",
    	  axis.title = element_blank(),
    	  legend.text = element_text(size = 8)
    	  ) +
    	
      labs(
        title = paste0("fdmask 0.9, component: ", component.i, ", measure: ", stat.i)
      )
    
    print(p_bar)
    
    
  }
  
}



```

