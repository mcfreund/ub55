---
title: "Design matrix QC, UB55"
author: "mike freund"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    toc: true
    highlight: zenburn
---


```{r setup, include = FALSE}

## TODO:
## vif as function of dropping terms
##   - cumulative: polort 5, 5+4, 5+4+3, ..., 
##   - each own
## correlation matrices
## problem subjects:
##   - with > 10 vif for regressors of interest: why?
##      - co-linearity with motion, polort, as result of censoring?
##      
##  1. ID 'bad subjects' for each regressor of interest with threshold on VIF
##  2. plot motion R^2, polort R^2, param of interest R^2, by group (bad, good subj)
##  3. 
##    correlation wtih censoring by group
##    # frames censored by group
##    ssq(fd) by group
##    

knitr::opts_chunk$set(echo = FALSE, fig.align = 'center', cache = TRUE)

library(here)
library(dplyr)
library(magrittr)
library(data.table)
library(mikeutils)
library(gifti)
library(cifti)
library(abind)

library(ggplot2)
library(grid)
library(gridExtra)
library(cowplot)


source(here("code", "glms", "write-events_funs.R"))
source(here("code", "read-behav.R"))

dir.analysis <- here("out", "glms")


## settings

theme_set(theme_bw(base_size = 12))




dir.analysis

read_xmat










# ## xmats
# 
# xmats <- readRDS(here("xmat_qc", "out", "xmats_dmcc2.RDS"))

## strings

subjs <- dimnames(xmats[[1]][[1]])$subj
tasks <- c("Axcpt", "Cuedts", "Stern", "Stroop")
sessi <- c("baseline", "proactive", "reactive")

## remove bad subjs

is.bad.subj <- logical(length(subjs))
names(is.bad.subj) <- subjs

for (task.i in seq_along(xmats)) {
  for (sess.i in seq_along(xmats[[task.i]])) {
    has.no.xmat <- apply(xmats[[task.i]][[sess.i]], "subj", function(.) any(is.na(.)))
    is.bad.subj[has.no.xmat] <- TRUE
  }
}

sum(is.bad.subj)

for (task.i in seq_along(xmats)) {
  for (sess.i in seq_along(xmats[[task.i]])) {
    xmats[[task.i]][[sess.i]] <- xmats[[task.i]][[sess.i]][, , !is.bad.subj]
  }
}


```

# About

Calculates variance inflation factors for DMCC2 "hi/lo" mixed (block+event) models.

Reads list of design matrices from .RDS file https://github.com/ccplabwustl/R01/blob/master/freund/xmat_qc/out/xmats_dmcc2.RDS.
This file was generated by the script https://github.com/ccplabwustl/R01/blob/master/freund/xmat_qc/src/read_xmats_dmcc2.R.

Included subjects with complete set of design matrices from all tasks\*sessions, with no truncated runs.

`r length(subjs)` met criteria:

```{r}
subjs
```


# VIF

Variance inflation factor indicates how much the variance of an estimated regression coefficient is inflated as a result of collinearity.
[See wiki here](https://en.wikipedia.org/wiki/Variance_inflation_factor).

The VIF can be understood as follows:

To calculate the VIF for a linear model $\mathbf{y} \sim \mathbf{X}\mathbf{b}$ with design matrix $\mathbf{X}$ of $p$ predictors $(\mathbf{x}_1, \dots, \mathbf{x}_p)$, each predictor $i$ is linearly modeled as a function of the other predictors $-i$: $\mathbf{x}_i \sim \mathbf{X}_{(-i)}\mathbf{b}_{(-i)}$.
The VIF is the inverse of the proportion of unexplained variance from this regression: $\text{VIF}_i = \frac{1}{1 - R^2}$.

When VIF is high, the variance of the coefficient in question is inflated relative to a regression estimating that coefficient alone, reducing power as a result. A VIF of $\geq 10$ is used as a rule-of-thumb for identifying problematically high collinearity.


```{r vifs, warning = FALSE}

## estimate VIFs ----

## regexp patterns for regressors to exclude:
models <- c(
  ## "full model":
  "include_all",
  ## "reduced polorts" models:
  "Pol#[5-6]", "Pol#[4-6]", "Pol#[3-6]", "Pol#[2-6]", "Pol#[1-6]", "Pol#[0-6]",
  ## "no movregs" model:
  "movregs",
  ## no baseline model
  "Pol|movregs",
  ## "no events" model:
  "AX#|AY#|Ang#|BX#|BY#|Bng#|ConInc#|ConNoInc#|InConInc#|InConNoInc#|LL5NP#|LL5NN#|LL5RN#|not5NP#|not5NN#|not5RN#|PC50Con#|PC50InCon#|biasCon#|biasCon#|biasInCon#|buffCon#",
  ## "N tents - 1"
  "AX#[8]|AY#[8]|Ang#[8]|BX#[8]|BY#[8]|Bng#[8]|ConInc#[8]|ConNoInc#[8]|InConInc#[8]|InConNoInc#[8]|LL5NP#[9]|LL5NN#[9]|LL5RN#[9]|not5NP#[9]|not5NN#[9]|not5RN#[9]|PC50Con#[5]|PC50InCon#[5]|biasCon#[5]|biasCon#[5]|biasInCon#[5]|buffCon#[5]",
  ## "N tents - 2"
    "AX#[7-8]|AY#[7-8]|Ang#[7-8]|BX#[7-8]|BY#[7-8]|Bng#[7-8]|ConInc#[7-8]|ConNoInc#[7-8]|InConInc#[7-8]|InConNoInc#[7-8]|LL5NP#[8-9]|LL5NN#[8-9]|LL5RN#[8-9]|not5NP#[8-9]|not5NN#[8-9]|not5RN#[8-9]|PC50Con#[4-5]|PC50InCon#[4-5]|biasCon#[4-5]|biasCon#[4-5]|biasInCon#[4-5]|buffCon#[4-5]"
)

names(models) <- c(
  "full.model",
  "polort<5","polort<4", "polort<3", "polort<2", "polort<1", "polort<0",
  "no.movregs", 
  "no.baseline",
  "no.events",
  "n.tent.minus1",
  "n.tent.minus2"
  )

vifs <- vector("list", length(tasks) * length(sessi) * length(models))  ## storage list
names(vifs) <- paste0(tasks, "_", sessi, "_", models)  ## for indexing


for (task.i in seq_along(tasks)) {
  # task.i = 4
  
  name.task.i <- tasks[task.i]
  
  for (sess.i in seq_along(sessi)) {
    # sess.i = 2
    
    name.sess.i <- sessi[sess.i]
    
    xmat.i <- xmats[[name.task.i]][[name.sess.i]]
    
    for (model.i in seq_along(models)) {
      # model.i = 1
      
      pattern <- models[model.i]

      is.included <- !grepl(pattern, dimnames(xmat.i)$regressor)
      
      ## NB
      ## gives warning wrt no intercept: OK
      ## it seems afni fits a 'no-intercept' model, with a dummy-code for each run.
      ## i.e., each run has a separate intercept, with no 'grand' intercept.
      vifs.i <- apply(xmat.i[, is.included, ], "subj", function(.) car::vif(lm(1:nrow(.) ~ . - 1, as.data.frame(.))))
      
      ## reshape to long data.frame:
      
      vifs.i <- reshape2::melt(vifs.i, value.name = "vif", varnames = c("regressor", "subj"))
      vifs.i$task <- name.task.i
      vifs.i$session <- name.sess.i
      vifs.i$model <- names(pattern)
      
      name.vif.i <- paste0(name.task.i, "_", name.sess.i, "_", pattern)
      vifs[[name.vif.i]] <- vifs.i
      
      rm(vifs.i)
      
    }
    
  }

}

vifs <- do.call(rbind, vifs)


## create label column for plotting ----

# unique(vifs$regressor)
vifs$regressor.type <- ""
vifs$regressor.type[grep("block", vifs$regressor)] <- "block"
vifs$regressor.type[grep("movreg", vifs$regressor)] <- "movreg"
vifs$regressor.type[grep("Pol", vifs$regressor)] <- "polort"
vifs$regressor.type[-grep("block|movreg|Pol", vifs$regressor)] <- "event"

```

# distribution of VIFs for "regressors of interest" across subjects

Of the "regressors of interest", only the sustained "BLOCK" regressors have problematically high collinearity.

```{r vifs_plot, fig.width = 10, fig.height = 15}

vifs %>% 
  filter(regressor.type %in% c("event", "block"), model == "full.model") %>%
  ggplot(aes(regressor, vif, fill = regressor.type)) +
  facet_grid(vars(task), vars(session), scales = "free") +
  geom_hline(yintercept = 10, color = "firebrick") +
  geom_boxplot() +
  coord_flip() +
  theme(axis.text.y = element_text(size = 6), legend.position = c(0.9, 0.9)) +
  scale_fill_brewer(type = "qual", palette = 2) +
  labs(subtitle = "red vertical line indicates VIF = 10")

```


# Reducing BLOCK collinearity

Which regressors are collinear with the BLOCK regressor?

Here I evaluate a variety of 'reduced' models, by removing certain regressors and re-estimating the VIFs for the sustained BLOCK regressor.

* __full.model__: the original model (those evaluated above)
* __polort<N__: full model, without polort < N (polort 0 indicates the run-specific intercept)
* __no.movregs__: full model, without movregs
* __no.baseline__: full model, without polorts (including run-specific intercepts) and movement regressors
* __no.events__: full model, without events
* __n.tent.minus1__: full model, without final tent knot for each event (Axpct knot 8, Cuedts knot 8, Stern knot 9, Stroop knot 5)
* __n.tent.minus1__: full model, without final and penultimate tent knot for each event (Axpct knot 7-8, Cuedts knot 7-8, Stern knot 8-9, Stroop knot 4-5)

```{r reducing_block_vif, fig.height = 7, fig.width = 10}

vifs %>% 
  filter(regressor == "`block#0`") %>%
  mutate(model = factor(model, levels = rev(names(models)))) %>%
  ggplot(aes(model, vif)) +
  facet_grid(vars(task), vars(session), scales = "free") +
  geom_hline(yintercept = 10, color = "firebrick") +
  geom_boxplot(fill = "steelblue4") +
  theme(legend.position = "none") +
  coord_flip() +
  labs(subtitle = "red vertical line indicates VIF = 10")

```

# conclusions

* The BLOCK collinearity does not seem to be explained by the complexity of the polort baseline, nor the movement regressors.
* Rather it seems to result from a redundancy with the events.
* Reducing the number of tent knots for events (up to a reduction of 2 knots) had a negligible impact on block VIFs.
* One solution to this may be using fixed-shape HRFs for the events.
* __TODO__: run same stats on design matrices from fixed-shape Stroop GLMs.
