---
title: 'task axis projection: simulation / recovery analysis'
author: "michael freund"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: 3
    highlight: zenburn
    number_sections: true
    theme: spacelab

---


# intro



## Purpose


```{r setup, include = FALSE}

source(here::here("code", "_packages.R"))
source(here("code", "read-behav.R"))
source(here("code", "_vars.R"))
source(here("code", "_atlases.R"))
source(here("code", "_settings.R"))
source(here("code", "_funs.R"))


subjs <- subjs[!subjs %in% c("432332", "DMCC5820265")]


## design matrices:

X <- enlist(tasks)
X$Axcpt  <- readRDS(here("out", "glms", "xmats_Axcpt_baseline_Cues_EVENTS_censored_shifted.RDS"))
X$Cuedts <- readRDS(here("out", "glms", "xmats_Cuedts_baseline_CongruencySwitch_EVENTS_censored_shifted.RDS"))
X$Stern  <- readRDS(here("out", "glms", "xmats_Stern_baseline_ListLength_EVENTS_censored_shifted.RDS"))
X$Stroop <- readRDS(here("out", "glms", "xmats_Stroop_baseline_Congruency_EVENTS_censored_shifted.RDS"))

X <- map(X, ~.[, , subjs, ])  ## get good subjs

x <- lapply(X, reshape2::melt)


## numbers

n.vert <- 100
# n.trs <- n.trs / 2
n.subj <- length(subjs)
n.run <- 2

set.seed(0)
rsubj <- sample.int(n.subj, 10)


```



# specificity / false positive analysis



```{r}


set.seed(0)
A <- enlist(tasks)
for (name.task.i in tasks) {
  # name.task.i = "Axcpt"
  
   
  ## simulate
  
  Y <- array(
    rnorm(prod(n.trs[name.task.i] / 2, n.vert, n.subj, n.run)), 
    dim = c(tr = n.trs[name.task.i] / 2, vertex = n.vert, subj = n.subj, run = n.run),
    dimnames = list(tr = NULL, vertex = NULL, subj = subjs, run = NULL)
  )

  X_i <- X[[name.task.i]]
  
  projs <- array(
    NA,
    dim = c(tr = n.trs[name.task.i] / 2, subj = n.subj, run = n.run),
    dimnames = list(tr = NULL, subj = subjs, run = NULL)
  )
  
  for (subj.i in seq_along(subjs)) {
    # subj.i = 1
    
    
    ## subset
    
    is.i <- X_i[, "is.included", subj.i, ] == 1
    j <- -grep("is.included", colnames(X_i))
    
    x1 <- X_i[, j, subj.i, 1]
    x2 <- X_i[, j, subj.i, 2]
    
    y1 <- Y[, , subj.i, 1]
    y2 <- Y[, , subj.i, 2]
    
    
    ## get axes
    

    b1 <- coef(.lm.fit(x1[is.i[, 1], ], y1[is.i[, 1]]))[colnames(x1) == "block#0", ]
    b2 <- coef(.lm.fit(x2[is.i[, 2], ], y2[is.i[, 2]]))[colnames(x2) == "block#0", ]
    
    
    ## get resids
    
    x1_noblock <- x1[, -grep("block#0", colnames(x1))]
    x2_noblock <- x2[, -grep("block#0", colnames(x2))]
    
    e1 <- resid(.lm.fit(x1_noblock, y1))
    e2 <- resid(.lm.fit(x2_noblock, y2))
    
    
    ## project
    
    b1u <- b1 / sqrt(sum(b1^2))
    b2u <- b2 / sqrt(sum(b2^2))
    
    p2 <- tcrossprod(b1u, e2)
    p1 <- tcrossprod(b2u, e1)
    
    
    projs[, subj.i, ] <- t(rbind(p1, p2))
    
    
  }
  
  
  A[[name.task.i]] <- projs
  
  
}


```


## results

```{r, fig.height = 8, fig.width = 15 , results = "asis"}


for (name.task.i in tasks) {
  # name.task.i = "Axcpt"
  
  cat("\n")
  cat(sprintf("\n### %s", name.task.i))
  cat("\n")
  
  
  a_i <- reshape2::melt(A[[name.task.i]])
  
  block.reg <- apply(X[[name.task.i]][, "block#0", , ], "tr", mean)
  is.block.change <- abs(diff(abs(diff(block.reg)) > 0.05)) != 0  ## large change in 2nd deriv (onset of ON and OFF)
  tr.block.change <- which(c(FALSE, is.block.change))

  
  p.ci <- a_i %>%
    
    ggplot(aes(tr, value)) +
    
    geom_vline(xintercept = tr.block.change, color = "black") +
    geom_hline(yintercept = 0, color = "grey70") +
    stat_summary(aes(group = run), fun.data = mean_cl_boot, geom = "ribbon", alpha = 0.75) +

    facet_grid(rows = vars(run)) +
    
    labs(title = paste0(name.task.i, " 95%CI, cross-run"))
    
  print(p.ci)
  
  
  p.t <- a_i %>%
  
    ggplot(aes(tr, value)) +
    
    geom_vline(xintercept = tr.block.change, color = "black") +
    geom_hline(yintercept = 0, color = "grey70") +
    stat_summary(aes(group = run), fun = ~t.test(.)$statistic, geom = "line", size = 1, color = "firebrick2") +
    
    facet_grid(rows = vars(run)) +
    
    labs(title = paste0(name.task.i, " t stat, cross-run"))
  
  print(p.t)

  
  
}




```



# sensitivity / false negative analysis


```{r}


set.seed(0)
A_signal <- enlist(tasks)
for (name.task.i in tasks) {
  # name.task.i = "Axcpt"
  
   
  ## simulate
  
  E <- array(
    rnorm(prod(n.trs[name.task.i] / 2, n.vert, n.subj, n.run)), 
    dim = c(tr = n.trs[name.task.i] / 2, vertex = n.vert, subj = n.subj, run = n.run),
    dimnames = list(tr = NULL, vertex = NULL, subj = subjs, run = NULL)
  )
  
  block.reg <- apply(X[[name.task.i]][, "block#0", , ], "tr", mean)  ## signal
  
  Y_true <- block.reg %*% t(rnorm(n.vert))  ## weights per vert
  # image(B_true)
  Y <- sweep(E, 1:2, Y_true, "+")
  
  
  X_i <- X[[name.task.i]]
  
  projs <- array(
    NA,
    dim = c(tr = n.trs[name.task.i] / 2, subj = n.subj, run = n.run),
    dimnames = list(tr = NULL, subj = subjs, run = NULL)
  )
  
  
  for (subj.i in seq_along(subjs)) {
    # subj.i = 1
    
    
    ## subset
    
    is.i <- X_i[, "is.included", subj.i, ] == 1
    j <- -grep("is.included", colnames(X_i))
    
    x1 <- X_i[, j, subj.i, 1]
    x2 <- X_i[, j, subj.i, 2]
    
    x1[, "block#0"] <- block.reg
    x2[, "block#0"] <- block.reg
    
    y1 <- Y[, , subj.i, 1]
    y2 <- Y[, , subj.i, 2]
    
    
    ## get axes
    

    b1 <- coef(.lm.fit(x1[is.i[, 1], ], y1[is.i[, 1]]))[colnames(x1) == "block#0", ]
    b2 <- coef(.lm.fit(x2[is.i[, 2], ], y2[is.i[, 2]]))[colnames(x2) == "block#0", ]
    
    
    ## get resids
    
    x1_noblock <- x1[, -grep("block#0|blockONandOFF", colnames(x1))]
    x2_noblock <- x2[, -grep("block#0|blockONandOFF", colnames(x2))]

    e1 <- resid(.lm.fit(x1_noblock, y1))
    e2 <- resid(.lm.fit(x2_noblock, y2))
    
    # e1 <- y1
    # e2 <- y2

    
    ## project
    
    b1u <- b1 / sqrt(sum(b1^2))
    b2u <- b2 / sqrt(sum(b2^2))
    
    p2 <- tcrossprod(b1u, e2)
    p1 <- tcrossprod(b2u, e1)
    
    
    projs[, subj.i, ] <- t(rbind(p1, p2))
    
    
  }
  
  
  A_signal[[name.task.i]] <- projs
  
  
}



```



## results

```{r, fig.height = 8, fig.width = 15 , results = "asis"}

for (name.task.i in tasks) {
  # name.task.i = "Cuedts"
  
  cat("\n")
  cat(sprintf("\n### %s", name.task.i))
  cat("\n")
  
  
  a_i <- reshape2::melt(A_signal[[name.task.i]])
  
  # block.reg <- apply(X[[name.task.i]][, "block#0", , ], "tr", mean)
  # is.block.change <- abs(diff(abs(diff(block.reg)) > 0.05)) != 0  ## large change in 2nd deriv (onset of ON and OFF)
  # tr.block.change <- which(c(FALSE, is.block.change))
  
  tr.block.change <- c(
    which(apply(X[[name.task.i]][, "blockONandOFF#0", , ], "tr", mean) > 0.9),
    which(apply(X[[name.task.i]][, "blockONandOFF#12", , ], "tr", mean) > 0.9)
  )
  
  
  p.ci <- a_i %>%
    
    ggplot(aes(tr, value)) +
    
    geom_vline(xintercept = tr.block.change, color = "black") +
    geom_hline(yintercept = 0, color = "grey70") +
    stat_summary(aes(group = run), fun.data = mean_cl_boot, geom = "ribbon", alpha = 0.75) +

    facet_grid(rows = vars(run)) +
    
    labs(title = paste0(name.task.i, " 95%CI, cross-run"))
    
  print(p.ci)
  
  
  p.t <-
    a_i %>%
  
    ggplot(aes(tr, value)) +
    
    geom_vline(xintercept = tr.block.change, color = "black") +
    geom_hline(yintercept = 0, color = "grey70") +
    stat_summary(aes(group = run), fun = ~t.test(.)$statistic, geom = "line", size = 1, color = "firebrick2") +

    facet_grid(rows = vars(run)) +
    
    labs(title = paste0(name.task.i, " t stat, cross-run"))
  
  print(p.t)

  
  p.subj <-
    a_i %>%
      
      filter(subj %in% subjs[rsubj]) %>%
  
      ggplot(aes(tr, value)) +
      
      geom_vline(xintercept = tr.block.change, color = "black") +
      geom_hline(yintercept = 0, color = "grey70") +
      geom_line(aes(group = subj, color = subj), size = 1) +
    
      facet_grid(rows = vars(subj), cols = vars(run))
      
      labs(title = paste0(name.task.i, " t stat, cross-run"))
  
  print(p.subj)

  
  
  
}




```



## design matrix analysis

```{r}


pinv <- enlist(tasks)
for (name.task.i in tasks) {
  # name.task.i = "Axcpt"
  
  X_i <- X[[name.task.i]]
  
  
  pinv_i <- enlist(subjs)
  
  
  for (subj.i in seq_along(subjs)) {
    # subj.i = 1
    
    
    ## subset
    
    is.i <- X_i[, "is.included", subj.i, ] == 1
    j <- -grep("is.included", colnames(X_i))
    # j <- grep("block#0|blockONandOFF", colnames(X_i))
    
    xi <- X_i[, j, subj.i, ]
    
    
    p1 <- data.frame(
      tr = which(is.i[, 1]),
      run1 = MASS::ginv(xi[is.i[, 1], , 1])[colnames(xi) == "block#0"]
    )
    p2 <- data.frame(
      tr = which(is.i[, 2]),
      run2 = MASS::ginv(xi[is.i[, 2], , 2])[colnames(xi) == "block#0"]
    )
    
    pinv_i[[subj.i]] <- full_join(p1, p2, by = "tr")
    
  }
  
  
  pinv[[name.task.i]] <- bind_rows(pinv_i, .id = "subj")
  
  
}

res <- bind_rows(pinv, .id = "task")


res %>%
  
  pivot_longer(cols = c("run1", "run2"), names_to = "run", values_to = "value") %>%
  
  ggplot(aes(tr, value)) +
  
  geom_line(aes(group = subj), alpha = 0.2) +
  stat_summary(fun = mean, geom = "line", color = "firebrick") +
  
  facet_grid(vars(task), vars(run))

x$Stern %>%
  
  filter(regressor == "block#0") %>%
  
  ggplot(aes(tr, value)) +
  
  # geom_line(aes(group = subj), alpha = 0.2) +
  stat_summary(fun = mean, geom = "line", color = "firebrick") +
  
  facet_grid(cols = vars(run))


weird.trs <- res %>%
  
  filter(task == "Stern", !is.na(run1)) %>%
  group_by(tr) %>%
  summarize(v = var(run1)) %>%
  filter(v < .Machine$double.eps) %>% pull(tr)
  


# image(X$Stern[weird.trs, , 49, 1])


```

